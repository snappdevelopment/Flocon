{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Flocon is an advanced debugging and inspection tool built with Kotlin Multiplatform (KMP), designed to work seamlessly across Android and desktop environments.  </p> <p>Inspired from Flipper by Meta, while leveraging modern Kotlin multiplatform architecture for networking, databases, analytics, and UI data visualization.</p> <p>It allows developers to connect a Kotlin Multiplatform or Android app to their computer and launch a desktop interface that can observe, inspect, and interact with the running app in real time \u2014 across shared Kotlin code and platform-specific implementations.</p> <p></p> <p>----&gt; Getting Started &lt;----</p> <p>Works on</p> Android Desktop (jvm) iOS (simulator) iOS (device) wasm Network \u2705 \u2705 \u2705 \u274c \u274c Database \u2705 \u2705 \u2705 \u274c \u274c Preference \u2705 \u274c \u274c \u274c \u274c Table \u2705 \u2705 \u2705 \u274c \u274c Analytics \u2705 \u2705 \u2705 \u274c \u274c Deeplink \u2705 \u274c \u274c \u274c \u274c Files \u2705 \u274c \u274c \u274c \u274c Images \u2705 \u2705 \u2705 \u274c \u274c Dashboards \u2705 \u274c \u274c \u274c \u274c <p>With Flocon, you gain deep access to critical app internals, such as - network requests (HTTP, gRPC, GraphQL, WebSockets) - mock network calls - local storage (sharedpref, databases, app files) - analytics events (and custom events) - debug menu displayed on the desktop - deeplinks</p> <p>and more \u2014 without needing root access or tedious ADB commands.</p> <p>It\u2019s designed for modern multiplatform development, accelerating debugging, QA, and iteration cycles.</p>"},{"location":"about/","title":"Story","text":""},{"location":"about/#why-the-name-flocon","title":"\ud83d\udc36 Why the name \"Flocon\" \u2728 ?","text":"<p>I was looking for a short, cute animal-inspired name \u2014 something in the spirit of \"Flipper\". I turned my head and saw my golden retriever, Flocon, smiling to me... and that was it.  That was all the inspiration I needed.  </p> <p>No brainstorming, no hesitation \u2014 just the perfect name at the perfect time.</p> <p></p>"},{"location":"analytics/","title":"Analytics","text":""},{"location":"analytics/#analytics-event-viewer","title":"\ud83d\udcca Analytics Event Viewer","text":"<p>Flocon shows a real-time stream of analytics events emitted by your application. Whether you\u2019re using Firebase Analytics, Segment, or a custom solution, the Flocon SDK can be plugged and forward these events to the desktop UI.</p> <p>Each event includes: - The event name - Parameters and metadata (key-value pairs) - Timestamps</p> <p>This is especially useful for QA teams and product analysts to validate that the right events are triggered at the right time with the correct payloads.</p>"},{"location":"analytics/#usage","title":"Usage","text":"<p>You can log events by identifying the source (e.g., <code>\"firebase\"</code>, <code>\"segment\"</code>, or any custom ID). Flocon Desktop will group events by these IDs.</p> <pre><code>floconAnalytics(\"firebase\").logEvents(\n    AnalyticsEvent(\n        eventName = \"clicked_user\",\n        \"userId\" analyticsProperty \"1024\",\n        \"username\" analyticsProperty \"florent\",\n        \"index\" analyticsProperty \"3\",\n    ),\n    AnalyticsEvent(\n        eventName = \"opened_profile\",\n        \"userId\" analyticsProperty \"2048\",\n        \"username\" analyticsProperty \"kevin\",\n        \"age\" analyticsProperty \"34\",\n    )\n)\n</code></pre>"},{"location":"analytics/#custom-analytics-wrapper","title":"Custom Analytics Wrapper","text":"<p>Often, you want to forward all your app's analytics to Flocon. You can easily do this in your analytics tracking implementation:</p> <pre><code>fun trackEvent(name: String, params: Map&lt;String, Any&gt;) {\n    // Forward to Flocon\n    floconAnalytics(\"app_events\").logEvents(\n        AnalyticsEvent(\n            eventName = name,\n            params.map { it.key analyticsProperty it.value.toString() }\n        )\n    )\n\n    // Original tracking (e.g., Firebase)\n    firebaseAnalytics.logEvent(name, bundleOf(...))\n}\n</code></pre>"},{"location":"contributors/","title":"Contributors","text":""},{"location":"contributors/#contributors","title":"\ud83e\udd1d Contributors","text":"<p>Thanks to these amazing people for making Flocon better every day!</p> <sub>florent37</sub> <sub>rteyssandier</sub> <sub>Woutervdvelde</sub> <sub>gdesantos</sub> <sub>Karambar</sub> <sub>Flakebi</sub> <sub>SimonMarquis</sub> <sub>StephenVinouze</sub> <sub>mdabash</sub>"},{"location":"contributors/#contributions","title":"Contributions","text":"<p><code>The project is open to contributions \u2014 feel free to submit a pull request!</code></p>"},{"location":"contributors/#license","title":"License","text":"<p>Flocon is MIT licensed, as found in the LICENSE file.</p>"},{"location":"dashboard/","title":"Dashboard","text":""},{"location":"dashboard/#configurable-dashboards","title":"\ud83d\udcc8 Configurable Dashboards","text":"<p>Your Android application can define and expose custom dashboards, which Flocon renders dynamically in the desktop interface.</p> <p>Use cases include: - Displaying live business metrics - Monitoring app state variables - Debugging real-time values (e.g., geolocation, battery, app mode) - Real-time in-app variables editing - Performing mobile callbacks from the desktop app</p>"},{"location":"dashboard/#basic-usage","title":"Basic Usage","text":"<p>Dashboards are defined programmatically on the mobile side via the SDK. They can be static or update live as data changes.</p> <pre><code>floconDashboard(id = \"main\") {\n    section(name = \"App Info\") {\n        text(label = \"Version\", value = \"1.0.0\")\n        label(label = \"Status: Online\")\n        button(\n            text = \"Reset Cache\",\n            onClick = { /* Handle click */ }\n        )\n    }\n}\n</code></pre>"},{"location":"dashboard/#reactive-dashboards","title":"Reactive Dashboards","text":"<p>You can bind a <code>section</code> to a Kotlin <code>Flow</code>. The section will automatically refresh in the Flocon Desktop app whenever the flow emits a new value.</p> <pre><code>floconDashboard(id = \"user_dashboard\") {\n    section(name = \"User Profile\", userFlow) { user -&gt;\n        text(label = \"Username\", value = user.name)\n        text(label = \"Email\", value = user.email)\n\n        textField(\n            label = \"Update Display Name\",\n            value = user.displayName,\n            onSubmitted = { newName -&gt;\n                userViewModel.updateName(newName)\n            }\n        )\n\n        checkBox(\n            label = \"Beta Tester\",\n            value = user.isBeta,\n            onUpdated = { enabled -&gt;\n                userViewModel.setBeta(enabled)\n            }\n        )\n    }\n}\n</code></pre>"},{"location":"dashboard/#available-elements","title":"Available Elements","text":"<p>Flocon provides several UI elements to build your dashboards:</p> Element Description <code>text</code> A labeled read-only text field. Supports custom colors. <code>label</code> A simple text label. <code>button</code> An actionable button that triggers a callback on the device. <code>textField</code> An input field that sends its content back to the device. <code>checkBox</code> A toggle switch for boolean values. <code>plainText</code> Optimized for displaying long strings or logs. <code>json</code> Renders a JSON string with syntax highlighting and tree view. <code>markdown</code> Renders rich text using Markdown syntax. <code>html</code> Renders basic HTML content."},{"location":"dashboard/#forms","title":"Forms","text":"<p>Use the <code>form</code> element to group multiple inputs with a single submit action.</p> <pre><code>floconDashboard(id = \"settings\") {\n    form(\n        name = \"App Settings\",\n        submitText = \"Save Changes\",\n        onSubmitted = { values -&gt;\n            val theme = values[\"theme_input\"]\n            val notifications = values[\"notif_check\"]\n            // Save settings...\n        }\n    ) {\n        textField(id = \"theme_input\", label = \"Theme Name\", value = \"Dark\")\n        checkBox(id = \"notif_check\", label = \"Enable Notifications\", value = true)\n    }\n}\n</code></pre>"},{"location":"dashboard/#rich-content","title":"Rich Content","text":"<p>You can also display rich content like Markdown or HTML.</p> <pre><code>floconDashboard(id = \"docs\") {\n    section(\"Documentation\") {\n        markdown(\n            label = \"Release Notes\",\n            value = \"\"\"\n                # Version 2.0\n                - Added **Reactive** support\n                - New `form` element\n            \"\"\".trimIndent()\n        )\n    }\n}\n</code></pre>"},{"location":"database/","title":"Database","text":""},{"location":"database/#database-explorer-sql-editor","title":"\ud83e\udde9 Database Explorer &amp; SQL Editor","text":"<p>Flocon gives you direct access to your app\u2019s local databases (SQLite, Room, SQLDelight, etc.), with a clean interface for exploring schemas and querying data.</p> <p>Key capabilities include: - Automatic detection of all SQLite databases on Android. - Listing all tables and their schemas. - Running custom SQL queries with syntax highlighting. - Auto-updating queries and saving favorites. - Generating <code>INSERT</code> and <code>DELETE</code> queries automatically.</p>"},{"location":"database/#android-automatic-detection","title":"Android (Automatic Detection)","text":"<p>On Android, Flocon automatically scans your app's internal storage and lists all SQLite databases. You don't need additional configuration to see them in the desktop app.</p>"},{"location":"database/#manual-registration-android","title":"Manual Registration (Android)","text":"<p>If you want to use a custom display name or register an in-memory database, you can use <code>floconRegisterDatabase</code>:</p> <pre><code>// Register an In-Memory Room Database\nval dogDatabase = Room.inMemoryDatabaseBuilder(context, DogDatabase::class.java).build()\n\nfloconRegisterDatabase(\n    displayName = \"In-Memory Dogs\",\n    openHelper = dogDatabase.openHelper\n)\n</code></pre>"},{"location":"database/#multiplatform-desktop-ios","title":"Multiplatform (Desktop &amp; iOS)","text":"<p>For Kotlin Multiplatform projects (Desktop and iOS), you must provide the absolute path to the database file:</p> <pre><code>// On Desktop\nval dbFile = File(System.getProperty(\"java.io.tmpdir\"), \"app_database.db\")\n\nfloconRegisterDatabase(\n    displayName = \"App DB\",\n    absolutePath = dbFile.absolutePath,\n)\n</code></pre> <pre><code>// On iOS\nval dbPath = \"${documentDirectory()}/app_database.db\"\n\nfloconRegisterDatabase(\n    displayName = \"App DB\",\n    absolutePath = dbPath\n)\n</code></pre>"},{"location":"database/#database-query-logging","title":"Database Query Logging","text":"<p>Flocon can also track and display all SQL queries executed by your app in real-time. This is particularly useful for debugging transactions, performance issues, or verifying the exact SQL generated by ORMs like Room.</p> <p></p>"},{"location":"database/#room-integration","title":"Room Integration","text":"<p>For Room databases, you can easily log all queries by using the <code>setQueryCallback</code> method when building your database:</p> <pre><code>val dbName = \"dogs_database\"\nval database = Room.databaseBuilder(\n    context.applicationContext,\n    DogDatabase::class.java,\n    dbName\n).setQueryCallback({ sqlQuery, bindArgs -&gt; \n    // Log the query to Flocon\n    floconLogDatabaseQuery(\n        dbName = dbName, \n        sqlQuery = sqlQuery, \n        bindArgs = bindArgs\n    ) \n}, Executors.newSingleThreadExecutor())\n.build()\n</code></pre>"},{"location":"database/#manual-logging","title":"Manual Logging","text":"<p>If you are not using Room or want to log queries manually, you can use the <code>floconLogDatabaseQuery</code> function directly:</p> <pre><code>floconLogDatabaseQuery(\n    dbName = \"my_custom_db\",\n    sqlQuery = \"SELECT * FROM users WHERE id = ?\",\n    bindArgs = listOf(42)\n)\n</code></pre>"},{"location":"database/#sql-workspace","title":"SQL Workspace","text":"<p>The Flocon Desktop app provides a full SQL workspace where you can: 1. Explore: See all tables and their columns. 2. Query: Write any SQL query and see the results in a formatted table. 3. Favorites: Save your most used queries for quick access later. 4. Toolbox: Quickly generate common SQL statements from the UI.</p>"},{"location":"deeplink/","title":"Deeplinks","text":""},{"location":"deeplink/#deeplink-launcher-android-only","title":"\ud83d\udd17 Deeplink Launcher (android only)","text":"<p>Flocon includes a deeplink runner, which lists all the deeplinks supported by your app (either auto-discovered or manually registered).</p> <p>From the desktop UI, you can:</p> <ul> <li>Browse available deeplinks</li> <li>Enter parameters interactively</li> <li>Execute deeplinks directly on the device</li> <li>Instantly navigate to specific app screens</li> </ul> <p>No more typing long <code>adb shell am start</code> commands \u2014 Flocon makes deeplink testing accessible and efficient.</p> <p>You can configure deeplinks directly from your Android code!</p> <pre><code>floconDeeplink {\n    deeplink(\"flocon://home\")\n    deeplink(\"flocon://test\")\n    deeplink(\n        \"flocon://user/[userId]\",\n        label = \"User\",\n        parameters = {\n            \"userId\" withAutoComplete listOf(\"Florent\", \"David\", \"Guillaume\")\n        }\n    )\n    deeplink(\n        \"flocon://post/[postId]?comment=[commentText]\",\n        label = \"Post\",\n        description = \"Open a post and send a comment\"\n    )\n}\n</code></pre>"},{"location":"files/","title":"Files","text":""},{"location":"files/#file-explorer-android-only","title":"\ud83d\udcc1 File Explorer (android only)","text":"<p>Flocon allows you to explore the internal file storage of your Android application \u2014 something that typically requires ADB and knowledge of Android's file system.</p> <p>From the desktop app, you can:</p> <ul> <li>Browse directories within the app's sandbox</li> <li>View file metadata (size, modification date, path)</li> <li>Open or download files for inspection</li> </ul> <p>This feature is ideal for inspecting log files, cache data, downloaded assets, or exported config files.</p>"},{"location":"graphql/","title":"GraphQL","text":""},{"location":"graphql/#graphql-request-inspector","title":"\ud83d\udef0\ufe0f GraphQL Request Inspector","text":"<p>Flocon also supports GraphQL requests via a dedicated Apollo interceptor.</p> <p>Just like with REST, all outgoing GraphQL requests made through Apollo Client are captured and displayed in Flocon\u2019s interface \u2014 allowing you to debug your queries and mutations in real time.</p> <p>For each GraphQL call, you can inspect:</p> <ul> <li>Response data or error payload</li> <li>Headers, status code, and response time</li> <li>The operation type (query / mutation)</li> </ul> <pre><code>ApolloClient.Builder()\n            // just set your already configured with flocon okhttp interceptor client\n            .okHttpClient(client)\n            // regular builder methods\n            .build()\n</code></pre>"},{"location":"grpc/","title":"Grpc","text":"<p>Similar to network inteceptions, Flocon works with grpc </p> <p>it works with <code>io.grpc:grpc-android</code> : https://github.com/grpc/grpc-java</p> <p>[!WARNING] please ensure your version is at lease <code>1.70.0</code></p> <p></p> <p>[!IMPORTANT] While dealing with protobuf on Android projects, it's best to use its lighter artifact (protobuf-javalite or protobuf-kotlin-lite).  It might be that your project needs the larger protobuf version (protobuf-java or protobuf-kotlin). Flocon offers two interceptor artifacts that leverage a different JSON formatter. It declutters the JSON printing by removing unwanted fields with a dedicated formatter depending on the protobuf library. Make sure you choose the correct artifact.</p> <p><pre><code> // If you're using protobuf-javalite or protobuf-kotlin-lite\nimplementation(\"com.google.protobuf:protobuf-kotlin-lite:$PROTOBUF_VERSION\")\n\nimplementation(\"io.github.openflocon:grpc-interceptor-lite:LAST_VERSION\")\n</code></pre> or <pre><code>// If you're using protobuf-java or protobuf-kotlin\nimplementation(\"com.google.protobuf:protobuf-java:$PROTOBUF_VERSION\")\n\nimplementation(\"io.github.openflocon:grpc-interceptor:LAST_VERSION\") \n</code></pre></p> <pre><code>ManagedChannelBuilder\n            ...\n            .intercept(\n                FloconGrpcInterceptor()\n            )\n            .build()\n</code></pre>"},{"location":"image/","title":"Images","text":""},{"location":"image/#downloaded-image-viewer","title":"\ud83d\uddbc\ufe0f Downloaded Image Viewer","text":"<p>Flocon captures and displays images downloaded by the Android app, giving you a clear, visual representation of media fetched over the network \u2014 such as avatars, product thumbnails, banners, or any other images requested at runtime.</p> <p>For each image, Flocon shows:</p> <ul> <li>A live thumbnail preview of the image  </li> <li>The URL from which it was downloaded</li> <li>The download timestamp </li> </ul> <p>This feature is extremely useful for:</p> <ul> <li>Verifying that images are loading correctly and not broken  </li> <li>Debugging CDN issues, placeholders, or misconfigured URLs  </li> <li>Comparing image quality and compression at runtime  </li> <li>Inspecting lazy loading or image caching behaviors  </li> </ul> <p>Whether you're working on UI/UX, performance optimization, or just debugging a missing image, this tool gives you immediate visibility into every image fetched by your app.</p> <p>Usage with coil</p> <pre><code>// just add your okhttp client (with the flocon interceptor)\nSingletonImageLoader.setSafe {\n        ImageLoader.Builder(context = context)\n            .components {\n                // works also for ktor network fetcher\n                add(\n                    coil3.network.okhttp.OkHttpNetworkFetcherFactory(\n                        callFactory = {\n                            okHttpClient\n                        },\n                    ),\n                )\n            }\n            .build()\n}\n</code></pre>"},{"location":"macos-install/","title":"MacOS Install","text":""},{"location":"macos-install/#how-to-install-the-macos-app","title":"How to install the MacOS app ?","text":"<p>MacOS may block the first launch of the application because it was not downloaded from the App Store. You'll need to manually authorize it through your system settings.</p> <ol> <li>First, try to launch the app from the Applications folder. macOS will display a message stating that it cannot be opened.</li> </ol> <p></p> <ol> <li>Click on the <code>?</code> on top right of the dialog</li> </ol> <p></p> <ol> <li>On the system help page, click on the link \"Open privacy &amp; Security for me\"</li> </ol> <p></p> <ol> <li>Scroll down to the Security section. You should see a message mentioning the blocked application with an <code>Open Anyway</code> button.</li> </ol> <p></p> <ol> <li> <p>Click on this button \ud83d\ude02</p> </li> <li> <p>It opens again the first dialog, but with an additional button in the middle <code>Open Anyway</code></p> </li> </ol> <p></p> <ol> <li>Click on this button \ud83d\ude02 (it should ask you a password or fingerprint verification)</li> </ol>"},{"location":"network/","title":"REST","text":""},{"location":"network/#network-request-inspector-kotlin-multi-platform-compatible","title":"\ud83d\udce1 Network Request Inspector (kotlin multi platform compatible)","text":"<p>Flocon captures all outgoing network requests made by the Android app \u2014 whether they\u2019re simple REST API calls or complex multipart uploads \u2014 and displays them in an organized UI.</p> <p>For each request, you can inspect:</p> <ul> <li>HTTP method (GET, POST, etc.)</li> <li>Full URL</li> <li>Request headers and body</li> <li>Response headers and body</li> <li>Status code and response time</li> <li>Timestamp</li> </ul> <p>This feature is invaluable for diagnosing backend issues, debugging unexpected API failures, and verifying request payloads and authentication headers.</p>"},{"location":"network/#http-request-mocking-kotlin-multi-platform-compatible","title":"\ud83c\udfad HTTP Request Mocking (kotlin multi platform compatible)","text":"<p>Beyond simple inspection, Flocon now allows you to mock HTTP requests. This powerful feature gives you full control over your app's network layer without needing to change any code. You can intercept specific network calls and provide custom responses, making it easy to test various scenarios.</p> <p>With this feature, you can:</p> <ul> <li>Simulate network errors: Test how your app handles different HTTP status codes (e.g., 404 Not Found, 500 Server Error).</li> <li>Create test data: Mock responses with specific data to test different UI states, even if your backend isn't ready yet.</li> <li>Create a new mock from an existing request, then test your app with some differences inside the prefious body</li> <li>Reduce dependencies: Develop and test features without needing a stable internet connection or a complete backend environment.</li> </ul>"},{"location":"network/#with-okhttp-android-only","title":"With OkHttp (android only)","text":"<pre><code>debugImplementation(\"io.github.openflocon:flocon-okhttp-interceptor:LAST_VERSION\")\nreleaseImplementation(\"io.github.openflocon:flocon-okhttp-interceptor-no-op:LAST_VERSION\")\n</code></pre> <pre><code>val okHttpClient = OkHttpClient()\n            .newBuilder()\n            .addInterceptor(FloconOkhttpInterceptor())\n            .build()\n</code></pre>"},{"location":"network/#with-ktor-kotlin-multi-platform-compatible","title":"With Ktor (kotlin multi platform compatible)","text":"<p>tested with ktor <code>3.2.3</code></p> <pre><code>debugImplementation(\"io.github.openflocon:flocon-ktor-interceptor:LAST_VERSION\")\nreleaseImplementation(\"io.github.openflocon:flocon-ktor-interceptor-no-op:LAST_VERSION\")\n</code></pre> <pre><code>val httpClient = HttpClient(YourClient) { \n    install(FloconKtorPlugin)\n    ...\n}\n</code></pre>"},{"location":"setup/","title":"Setup","text":"<p>\ud83d\udee0\ufe0f Getting Started</p>"},{"location":"setup/#installation","title":"Installation","text":"<p>in your module .kts</p> <p> <pre><code>debugImplementation(\"io.github.openflocon:flocon:LAST_VERSION\")\nreleaseImplementation(\"io.github.openflocon:flocon-no-op:LAST_VERSION\")\n</code></pre></p> <p>in your <code>Application.kt</code> <pre><code>// android initialization\nFlocon.initialize(this)\n\n// desktop / ios\nFlocon.initialize()\n</code></pre></p> <pre><code>[versions]\nflocon = \"LASTEST_VERSION\"\n\n[libraries]\nflocon = { module = \"io.github.openflocon:flocon\", version.ref = \"flocon\" }\n</code></pre> <p>Download &amp; install the last Desktop client</p> <p>[!NOTE] If you are on MacOS, you might need to follow specific instructions to open the app. See MacOS Installation.</p>"},{"location":"setup/#requirements","title":"\ud83e\uddf0 Requirements","text":""},{"location":"setup/#for-android","title":"for android","text":"<ul> <li>An Android device with USB debugging enabled</li> <li>Android Studio or SDK tools installed</li> <li>ADB (Android Debug Bridge) accessible from your system path</li> </ul>"},{"location":"setup/#for-all-platforms","title":"for all platforms","text":"<ul> <li>Flocon Desktop app (JVM-based)</li> <li>Flocon SDK integrated into your app</li> <li>At least <code>kotlin 2.0.0</code> in your app</li> <li>Be aligned between the mobile library version &amp; the desktop app version</li> </ul>"},{"location":"sharedpref/","title":"Shared Preferences","text":""},{"location":"sharedpref/#preferences-explorer-editor","title":"\ud83d\udddd Preferences Explorer &amp; Editor","text":"<p>Flocon provides complete access to your app\u2019s preferences (SharedPreferences and DataStore), which often store user tokens, feature flags, configuration options, and more.</p> <p>Key capabilities include: - Automatic detection of all application SharedPreferences. - Viewing and filtering key-value pairs. - Inspecting primitive values and JSON structures. - Editing values on the fly from the desktop UI.</p>"},{"location":"sharedpref/#sharedpreferences","title":"SharedPreferences","text":"<p>Flocon automatically detects and displays all standard <code>SharedPreferences</code> files in your application. However, you can manually register them to provide custom names:</p> <pre><code>val referencedPref = context.getSharedPreferences(\"user_pref\", Context.MODE_PRIVATE)\nfloconRegisterPreference(FloconSharedPreference(name = \"User Settings\", referencedPref))\n</code></pre>"},{"location":"sharedpref/#jetpack-datastore","title":"Jetpack DataStore","text":"<p>To support Jetpack DataStore, ensure you have the <code>flocon-datastore</code> dependency:</p> <pre><code>// build.gradle.kts\nimplementation(\"io.github.openflocon:flocon-datastore:version\")\n</code></pre> <p>Then register your DataStore:</p> <pre><code>val Context.dataStore by preferencesDataStore(name = \"settings\")\n\n// Registration\nfloconRegisterPreference(FloconDatastorePreference(name = \"App Settings\", context.dataStore))\n</code></pre>"},{"location":"sharedpref/#custom-implementations","title":"Custom Implementations","text":"<p>You can expose any key-value store to Flocon by implementing the <code>FloconPreference</code> interface. This is useful for custom encrypted storage or non-standard persistence layers.</p> <pre><code>class MyCustomPreference : FloconPreference {\n    override val name: String = \"Custom Store\"\n\n    override suspend fun columns(): List&lt;String&gt; {\n        return listOf(\"api_key\", \"debug_mode\")\n    }\n\n    override suspend fun get(columnName: String): FloconPreferenceValue? {\n        // Retrieve value from your store\n        return FloconPreferenceValue(stringValue = \"...\")\n    }\n\n    override suspend fun set(columnName: String, value: FloconPreferenceValue) {\n        // Save value to your store\n    }\n}\n\n// Registration\nfloconRegisterPreference(MyCustomPreference())\n</code></pre>"},{"location":"table/","title":"Tables","text":""},{"location":"table/#structured-data-tables","title":"\ud83d\udccb Structured Data Tables","text":"<p>In addition to dashboards, Flocon supports structured data tables (compatible with Kotlin Multiplatform). These allow you to visualize lists of items with multiple columns directly in the desktop interface.</p> <p>Use cases include: - Displaying active user sessions. - Inspecting items in local memory or cache. - Monitoring custom business events. - Comparing simulated backend responses.</p> <p>Tables are interactive, scrollable, and provide a clear way to inspect real-time collections.</p>"},{"location":"table/#usage","title":"Usage","text":"<p>To log a new row in a table, identify the table by name and use the <code>log</code> method with the <code>toParam</code> DSL to define column values.</p> <pre><code>floconTable(\"active_sessions\").log(\n    \"user_id\" toParam \"1024\",\n    \"name\" toParam \"Florent\",\n    \"status\" toParam \"Active\",\n    \"last_seen\" toParam \"2023-10-27 10:00\"\n)\n</code></pre>"},{"location":"table/#real-time-updates","title":"Real-time Updates","text":"<p>Whenever you call <code>.log()</code>, a new row is appended to the corresponding table in Flocon Desktop. This makes it ideal for tracking events or state changes over time.</p> <pre><code>fun onUserAction(user: User, action: String) {\n    floconTable(\"user_actions\").log(\n        \"timestamp\" toParam currentTimeMillis().toString(),\n        \"user\" toParam user.name,\n        \"action\" toParam action\n    )\n}\n</code></pre>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#why-flocon-cant-see-your-device-calls-and-how-to-fix-it","title":"\ud83d\udea8 Why Flocon Can\u2019t See Your Device Calls (And How to Fix It) \ud83d\udea8","text":"<p>To enable Flocon to intercept and inspect network traffic from your Android app,  the app must be allowed to connect to <code>localhost</code> (typically <code>127.0.0.1</code>), which is where the desktop companion listens for traffic.</p> <p>If you're already using a custom <code>networkSecurityConfig</code>, make sure it includes a rule to allow cleartext traffic to <code>localhost</code></p> <p>AndroidManifest.xml <pre><code>&lt;application\n        android:networkSecurityConfig=\"@xml/network_security_config\"/&gt;\n</code></pre></p> <p>network_security_config.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;network-security-config&gt;\n    &lt;domain-config cleartextTrafficPermitted=\"true\"&gt;\n        &lt;domain includeSubdomains=\"true\"&gt;localhost&lt;/domain&gt;\n        &lt;domain includeSubdomains=\"true\"&gt;127.0.0.1&lt;/domain&gt;\n    &lt;/domain-config&gt;\n&lt;/network-security-config&gt;\n</code></pre></p>"},{"location":"websocket/","title":"Websocket","text":""},{"location":"websocket/#inspect-websockets","title":"\ud83d\udcac Inspect Websockets","text":"<p>Flocon doesn\u2019t stop at HTTP \u2014 it also captures all WebSocket communications made by your Android app. This allows you to inspect real-time data exchanges between your app and the server with full visibility.</p> <p>For each WebSocket connection, you can inspect:</p> <ul> <li>Connection URL  </li> <li>Sent and received frames (text, binary, ping/pong)  </li> <li>Timestamps and message order  </li> <li>Payloads </li> <li>Closes</li> </ul> <p>With this feature, you can:</p> <ul> <li>Debug real-time features like chat, live feeds, or multiplayer updates  </li> <li>Verify the exact content of messages exchanged  </li> <li>Diagnose disconnection or synchronization issues  </li> </ul>"},{"location":"websocket/#with-okhttp3-android-only","title":"With OkHttp3 (android only)","text":"<p>Flocon-Okhttp-Interceptor has built-in websocket methods (\u26a0\ufe0f it's not possible through interceptors \u26a0\ufe0f) </p> <p>To log outgoing messages  <pre><code>webSocket.sendWithFlocon(\"\\\"$text\\\"\") // extension method that log to Flocon and performs the send\n</code></pre></p> <p>To log incoming messages  <pre><code>val request = Request.Builder()\n       .url(\"wss://.......\")\n       .build()\nval listener = object : WebSocketListener() {\n      // your listener\n}\n\nwebSocket = client.newWebSocket(\n      request,\n      listener.listenWithFlocon(id = \"wss://.......\"), // extension method that wraps an existing WebSocketListener\n    )\n}\n</code></pre></p>"},{"location":"websocket/#manually-kotlin-multi-platform-compatible","title":"\ud83e\uddf0 Manually (kotlin multi platform compatible)","text":"<p>If you are using other websockets libs than okhttp, you can easily forward events to FloconWebSocket</p> <p>To log outgoing messages  <pre><code>val message = \"hello\"\n\nwebSocket.send(message)\n\nfloconLogWebSocketEvent(\n    FloconWebSocketEvent(\n        websocketUrl = \"ws://...\",\n        event = FloconWebSocketEvent.Event.SendMessage,\n        message = message,\n    )\n)\n</code></pre></p> <p>To log incoming messages  <pre><code>myCustomWebSocket.onReceived {\n    floconLogWebSocketEvent(\n        FloconWebSocketEvent(\n        websocketUrl = \"ws://...\"\n        event = FloconWebSocketEvent.Event.ReceiveMessage,\n        message = it,\n    )\n    // handle your message\n)\n</code></pre></p>"}]}